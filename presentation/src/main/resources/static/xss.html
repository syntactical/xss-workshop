<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Cross Site Scripting</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <style type="text/css">
        pre.bigcode {
            text-align: center;
            font-size: 1em
        }

        pre.medcode {
            text-align: center;
            font-size: 0.7em
        }

        #speaker-controls {
            font-size: 0.3em
        }

        .present ul li {
            margin-bottom: 0.5em
        }
    </style>

    <style type="text/css">
        .reveal p {
            margin-left: 50px;
            margin-right: 50px;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

        <section>
            <h1>Cross Site Scripting</h1>

            <h3>OWASP #3</h3>
        </section>

        <section>
            <h2>What is XSS?</h2>
        </section>

        <section>
            <h2>What is XSS? The Simple definition</h2>
            <p>
                JavaScript, HTML, or CSS where it doesn’t belong messing with your app.
            </p>
        </section>

        <section>
            <h2>Persistent XSS</h2>
            <img src="img/persistent-xss.png" style="width: 800px;"/>
            <aside class="notes">
                <ul>
                    <li>
                        Persistent XSS
                        <ul>
                            <li>Persistent XSS is, by definition, stored on a server somewhere and delivered
                                out-of-band. I
                                think of it as the avatar or comment-page vulnerability:
                            </li>
                            <li>Imagine you could put any unrestricted content in a facebook post, including
                                JavasScript, CSS,
                                HTML, etc. You could set your profile to contain JavaScript that would, for example
                                <ul>
                                    <li>Prompt for a username and password</li>
                                    <li>Steal session information</li>
                                    <li>Show and/or hide different parts of the page</li>
                                </ul>
                            </li>
                            <li>You save it in one session and it appears to users in another. Depending on the level of
                                auditing and anonymity of posting, finding the source of the problem would be very
                                challenging
                            </li>
                        </ul>

                    </li>
                </ul>
            </aside>
        </section>

        <section>
            <h2>Reflected XSS</h2>
            <img src="img/reflected-xss.png" style="width: 800px;"/>
            <aside class="notes">
                <ul>
                    <li>
                        Reflected XSS
                        <ul>
                            <li>Reflected XSS can be dangerous but cannot be delivered asynchronously like a persistent
                                XSS attack
                            </li>
                            <li>In this case, the dangerous payload must be delivered via GET parameters or POST
                                payload
                            </li>
                            <li>That means the attacker needs to send you a link, directing you to an endpoint they
                                control in
                                some way, perhaps via email or IM. You click on that link, and the malicious content
                                from the
                                URL is rendered to the page
                            </li>
                            <li>The effect of server and client reflected XSS is basically the same, but implementing
                                controls
                                is a bit different because of where the they exist.
                            </li>
                            <li>Client is by definition in JavaScript
                            <li>Server is whatever your server-side web application platform

                        </ul>
                    </li>
                    <li>The only difference between client and server reflected is the mechanism by which the attacker
                        content is included in the page. For server-reflected, a GET, POST, header, param, whatever is
                        included during server-side page rendering.
                    </li>
                    <li>For DOM-based, JS is rendering things params or cookies directly into the page.</li>
                    <li>The former is tricky because there are more ways to create this vulnerability. You can render
                        anything in the request, really.
                    </li>
                    <li>The latter can only be via GET parameter, cookies and headers (if using Ajax). Data like POST
                        body isn’t accessible.
                    </li>
                    <li>Either way, the effect is the same, attacker content is “bounced” through the request onto the
                        page.
                    </li>
                </ul>
            </aside>
        </section>

        <section>
            <h2>XSS Scavenger Hunt!</h2>
        </section>

        <section>
            <h2>Why does XSS happen?</h2>
        </section>

        <section>
            <h2>Why does XSS happen?</h2>
            <p>The line between executable code and data is murky.</p>
        </section>

        <section>
            <h2>Let's say you show your product owner a XSS vulnerability, and they say, "So what?"</h2>
        </section>

        <section>
            <h2>Did you touch on...</h2>
            <ul>
                <li>Confidentiality?</li>
                <li>Integrity?</li>
                <li>Availability?</li>
            </ul>
            <aside class="notes">
                Availability is not as much a concern. It may be used as a stepping stone towards poor availability but it's not a main concern.
            </aside>
        </section>

        <section>
            <h2>Defending against XSS</h2>
            <ul>
                <li>Input validation</li>
                <li>Output encoding</li>
                <li>Safe script includes</li>
                <li>Avoid mixed contexts</li>
                <li>Avoid "unsafe" JavaScript like eval() and innerHTML</li>
            </ul>
            <aside class="notes">

            </aside>
        </section>

        <section>
            <h2>Input Validation: Basic Case</h2>
            <table>
                <thead>
                <tr>
                    <td>Input</td>
                    <td>Output</td>
                </tr>
                <tr></tr>
                </thead>
                <tbody>
                <tr>
                    <td>42</td>
                    <td>2a</td>
                </tr>
                <tr>
                    <td>2001</td>
                    <td>7da</td>
                </tr>
                <tr>
                    <td>
                        &lt;script&gt;alert(“gotcha”);&lt;/script&gt;
                    </td>
                    <td>
                        ???
                    </td>
                </tr>
                </tbody>

            </table>
            <aside class="notes">
                <p>untrusted data: "the most fundamental core idea of secure coding"</p>
            </aside>
        </section>

        <section>
            <h2>Being Too Helpful</h2>
            <img src="img/error-popup.png" style="width: 600px;"/>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <h2>More Complex Cases</h2>
            <ul>
                <li>A web-based email client</li>
                <li>A web-based ssh client</li>
                <li>Or, heaven help you, a web-based HTML editor</li>
            </ul>
            <aside class="notes">
                <ul>
                    <li>In these cases, you don’t have the luxury of eliminating huge swaths of characters. So it is
                        worth limiting your input as much as possible, but now you are reliant on output encoding.
                        Output encoding is much trickier and harder to practice the positive modeling that I recommend
                        so heavily.
                    </li>
                    <li>Black-listing is very hard to get right, particularly given the complexities of International
                        character sets which you most likely need to support.
                    </li>
                    <li>Instead you may be force to take in a wide range of input, but control what is rendered. At this
                        point context is critical.
                    </li>
                    <li>To give you a taste of the different types of contexts you need to be aware of…. NEXT SLIDE</li>
                </ul>
            </aside>
        </section>

        <section>
            <h2>Browser Rendering Contexts</h2>
            <ul>
                <li>HTML context</li>
                <li>HTML attribute context</li>
                <li>JavaScript context</li>
                <li>JavaScript string context</li>
                <li>CSS context</li>
                <li>JSON entity context</li>
                <li>URL context</li>
            </ul>
            <aside class="notes">
                Each of these contexts is governed by a different set of rules. For example, what happens when an attacker manages to squeeze a less-than and greater-than into an HTML page? Or a quote into a bit of JS?
                To make things worse, these contexts can be nested and the complexity increases dramatically.
            </aside>
        </section>

        <section>
            <h2>What is Output Encoding?</h2>

            <p>Escaping characters and sequences so they do not render in the wrong context</p>
            <img src="img/output-encoding.png" style="width:800px;"/>
        </section>

        <section>
            <h2>HTML Output Encoding</h2>
            <pre>
                <code>
                    $attackerInput="&lt;img src='http://evil.org/deface.gif'&gt;"

                    &lt;p&gt;$attackerInput&lt;/p&gt;

                    $attackerInput="&lt;img src='http://evil.org/deface.gif'&gt;"
                </code>

                Un-encoded
                <code>
                    &lt;p&gt;&lt;img src='http://evil.org/deface.gif'&gt;&lt;/p&gt;
                </code>

                Encoded
                <code>
                    &amp;lt;p&amp;gt;&amp;lt;img src='http://evil.org/deface.gif'&amp;gt;&amp;lt;/p&amp;gt;
                </code>
            </pre>
        </section>
        <section>
            <h2>JavaScript Output Encoding</h2>
            <pre>
                <code>
                    $attackerInput="\"); alert('gotcha');//"
                    &lt;script&gt;
                    doSomething("$attackerInput");
                    &lt;/script&gt;
                </code>
                    Unescaped
                <code>
                    &lt;script&gt;
                    doSomething(""); alert('gotcha');//");
                    &lt;/script&gt;
                </code>
                    Escaped
                <code>
                    &lt;script&gt;
                    doSomething("\x22\x29\x3B\x20alert\x28\x27gotcha\x27\x29\x3B\x2F\x2F");
                    &lt;/script&gt;
                </code>
            </pre>
        </section>

        <section>
            <h2>True or False</h2>
            <p>Even if you skip most input validation, good output encoding will save you from most XSS.</p>
            <aside class="notes">
                True
            </aside>
        </section>

        <section>
            <h2>True or False</h2>
            <p>If you have really good input validation, you can skip output encoding layer.</p>
            <aside class="notes">
                False
            </aside>
        </section>

        <section>
            <h2>True or False</h2>
            <p>It's okay to do input validation or output encoding.</p>
            <aside class="notes">
                False. It's always better to do both when you can, but output encoding is more important.
            </aside>
        </section>

        <section>
            <h2>When should you create your own encoder?</h2>
            <p>Don't unless you really have to. Popular encoders are included in the resources.</p>
        </section>

        <section>
            <h2>Fix XSS in the code</h2>
        </section>

        <section>
            <h2>What makes defending against XSS hard?<h2>
        </section>

        <section>
            <h2>What makes defending against XSS hard?</h2>
            <ul>
                <li>Large number of factors to think about</li>
                    <ul>
                        <li>Types of input to the HTTP request</li>
                        <li>Identify all the places where data will be included in the HTML</li>
                    </ul>
                <li>A defense that works in one context may not work in another</li>
                    <ul>
                        <li>HTML attribute VS Javascript variable assignment
                    </ul>
                <li>A defense that works with one kind of input will not work for another</li>
                    <ul>
                        <li>Validation and encoding for a username VS sanitization for untrusted HTML
                    </ul>
            </ul>
        </section>


        <section>
            <h2>References</h2>
            <ul>
                <li>
                    <a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP
                        XSS Cheat Sheet</a></li>
                <li>
                    <a href="https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)">OWASP Top 10 -
                        A3 – Cross-Site Scripting</a>
                </li>
                <li>
                    <p>OWASP Java Encoder, OWASP HTML Sanitizer, AntiSamy, JSON.parse (pattern of
            embedding it in html and having client side javascript interpret it),
            OWASP JSON sanitizer for server-side JSON handling</p>
                </li>
            </ul>
        </section>

        <section>
            <h2>Feedback?</h2>
            <p>What went well? Not so well? Suggestions/Questions?</p>
        </section>


    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,
        slideNumber: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        width: "95%",

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'plugin/notes/notes.js', async: true}
        ]
    });

</script>

</body>
</html>
